
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { MeasurementTool } from './MeasurementTool';
import { AnnotationTool } from './AnnotationTool';

interface ViewerCanvasProps {
  imageUrl: string;
  zoom: number;
  pan: { x: number; y: number };
  windowWidth: number;
  windowCenter: number;
  brightness: number;
  contrast: number;
  activeTool: 'pan' | 'zoom' | 'windowing' | 'measure' | 'annotate';
  onZoomChange: (zoom: number) => void;
  onPanChange: (pan: { x: number; y: number }) => void;
  onWindowingChange: (width: number, center: number) => void;
}

export function ViewerCanvas({
  imageUrl,
  zoom,
  pan,
  windowWidth,
  windowCenter,
  brightness,
  contrast,
  activeTool,
  onZoomChange,
  onPanChange,
  onWindowingChange,
}: ViewerCanvasProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [imageData, setImageData] = useState<HTMLImageElement | null>(null);
  const [measurements, setMeasurements] = useState([]);
  const [annotations, setAnnotations] = useState([]);

  // Load image
  useEffect(() => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      setImageData(img);
    };
    img.src = imageUrl;
  }, [imageUrl]);

  // Render canvas
  const renderCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!canvas || !ctx || !imageData) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Apply transformations
    ctx.save();
    ctx.translate(canvas.width / 2 + pan.x, canvas.height / 2 + pan.y);
    ctx.scale(zoom, zoom);

    // Apply image filters for windowing, brightness, and contrast
    const windowMin = windowCenter - windowWidth / 2;
    const windowMax = windowCenter + windowWidth / 2;
    
    ctx.filter = `brightness(${100 + brightness}%) contrast(${100 + contrast}%)`;

    // Draw image centered
    ctx.drawImage(
      imageData,
      -imageData.width / 2,
      -imageData.height / 2,
      imageData.width,
      imageData.height
    );

    ctx.restore();
  }, [imageData, zoom, pan, windowWidth, windowCenter, brightness, contrast]);

  // Update canvas size
  useEffect(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    const resizeCanvas = () => {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      renderCanvas();
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, [renderCanvas]);

  // Render when dependencies change
  useEffect(() => {
    renderCanvas();
  }, [renderCanvas]);

  // Mouse event handlers
  const handleMouseDown = (e: React.MouseEvent) => {
    if (activeTool === 'measure' || activeTool === 'annotate') return; // Let tools handle this
    
    setIsDragging(true);
    setDragStart({ x: e.clientX, y: e.clientY });
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || activeTool === 'measure' || activeTool === 'annotate') return;

    const deltaX = e.clientX - dragStart.x;
    const deltaY = e.clientY - dragStart.y;

    if (activeTool === 'pan') {
      onPanChange({
        x: pan.x + deltaX,
        y: pan.y + deltaY,
      });
    } else if (activeTool === 'windowing') {
      const sensitivity = 2;
      const newWidth = Math.max(1, windowWidth + deltaX * sensitivity);
      const newCenter = windowCenter + deltaY * sensitivity;
      onWindowingChange(newWidth, newCenter);
    }

    setDragStart({ x: e.clientX, y: e.clientY });
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    
    if (activeTool === 'zoom' || e.ctrlKey) {
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.max(0.1, Math.min(10, zoom * zoomFactor));
      onZoomChange(newZoom);
    }
  };

  const getCursor = () => {
    if (activeTool === 'measure') return 'crosshair';
    if (activeTool === 'annotate') return 'crosshair';
    switch (activeTool) {
      case 'pan': return isDragging ? 'grabbing' : 'grab';
      case 'zoom': return 'zoom-in';
      case 'windowing': return 'crosshair';
      default: return 'default';
    }
  };

  return (
    <div 
      ref={containerRef}
      className="w-full h-full bg-black relative overflow-hidden"
      style={{ cursor: getCursor() }}
    >
      <canvas
        ref={canvasRef}
        className="w-full h-full"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      />
      
      {/* Measurement overlay */}
      <MeasurementTool
        isActive={activeTool === 'measure'}
        zoom={zoom}
        onMeasurementsChange={setMeasurements}
      />
      
      {/* Annotation overlay */}
      <AnnotationTool
        isActive={activeTool === 'annotate'}
        annotations={annotations}
        onAnnotationsChange={setAnnotations}
      />
      
      {/* Image info overlay */}
      <div className="absolute top-4 left-4 text-white text-sm bg-black/50 px-2 py-1 rounded">
        Zoom: {(zoom * 100).toFixed(0)}%
      </div>
      
      <div className="absolute top-4 right-4 text-white text-sm bg-black/50 px-2 py-1 rounded">
        W: {windowWidth.toFixed(0)} | C: {windowCenter.toFixed(0)}
      </div>

      {/* Tool indicator */}
      <div className="absolute bottom-4 left-4 text-white text-xs bg-black/50 px-2 py-1 rounded">
        Tool: {activeTool.charAt(0).toUpperCase() + activeTool.slice(1)}
      </div>
      
      {/* Annotations counter */}
      {annotations.length > 0 && (
        <div className="absolute top-16 right-4 text-white text-xs bg-blue-600/80 px-2 py-1 rounded">
          {annotations.length} annotation{annotations.length !== 1 ? 's' : ''}
        </div>
      )}
    </div>
  );
}
